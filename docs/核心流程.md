# æ ¸å¿ƒæµç¨‹æ–‡æ¡£

## ğŸ”„ ä¸»è¦ä¸šåŠ¡æµç¨‹

### 1. System Prompt ç”Ÿæˆæ ¸å¿ƒæµç¨‹

```mermaid
flowchart TD
    Start([ç”¨æˆ·è¾“å…¥æ¶ˆæ¯]) --> Parse[è§£æç”¨æˆ·æ¶ˆæ¯]
    Parse --> Extract[æå–å…³é”®è¯]
    
    Extract --> Mode{é€‰æ‹©ç”Ÿæˆæ¨¡å¼}
    Mode -->|memory_only| LoadMem[åŠ è½½å›¢é˜Ÿè®°å¿†]
    Mode -->|framework_only| LoadFrame[åŠ è½½ä¸ƒæ­¥æ¡†æ¶]
    Mode -->|hybrid| LoadBoth[åŠ è½½è®°å¿†+æ¡†æ¶]
    
    LoadMem --> FilterMem[è¿‡æ»¤ç›¸å…³è®°å¿†]
    LoadFrame --> BuildFrame[æ„å»ºæ¡†æ¶å†…å®¹]
    LoadBoth --> FilterMem
    LoadBoth --> BuildFrame
    
    FilterMem --> ScoreEngine[æ™ºèƒ½è¯„åˆ†å¼•æ“]
    ScoreEngine --> SelectMem[é€‰æ‹©æœ€ç›¸å…³è®°å¿†]
    
    SelectMem --> Combine[ç»„åˆå†…å®¹]
    BuildFrame --> Combine
    
    Combine --> Generate[ç”ŸæˆSystem Prompt]
    Generate --> Save[ä¿å­˜åˆ°outputç›®å½•]
    Save --> Learn[è§¦å‘å­¦ä¹ æœºåˆ¶]
    Learn --> End([è¿”å›ç»“æœ])
    
    %% æ™ºèƒ½è¯„åˆ†è¯¦ç»†æµç¨‹
    ScoreEngine --> Keyword[å…³é”®è¯åŒ¹é…]
    ScoreEngine --> Semantic[è¯­ä¹‰ç›¸å…³æ€§]
    ScoreEngine --> Importance[é‡è¦æ€§æƒé‡]
    ScoreEngine --> Context[ä¸Šä¸‹æ–‡åˆ†æ]
    
    Keyword --> Score[è®¡ç®—ç»¼åˆåˆ†æ•°]
    Semantic --> Score
    Importance --> Score
    Context --> Score
    
    Score --> Rank[è®°å¿†æ’åº]
    Rank --> SelectMem
```

#### æµç¨‹è¯¦ç»†è¯´æ˜

**é˜¶æ®µ1: è¾“å…¥å¤„ç†**
- ç”¨æˆ·æä¾›æ¶ˆæ¯å’Œå›¢é˜Ÿåç§°
- ç³»ç»Ÿè§£ææ¶ˆæ¯å†…å®¹ï¼Œæå–æŠ€æœ¯å…³é”®è¯
- è¿‡æ»¤åœç”¨è¯ï¼Œè¯†åˆ«æŠ€æœ¯æœ¯è¯­

**é˜¶æ®µ2: æ¨¡å¼é€‰æ‹©**
- **memory_only**: ä»…åŸºäºå›¢é˜Ÿå†å²è®°å¿†ç”Ÿæˆ
- **framework_only**: ä»…åŸºäºä¸ƒæ­¥å¼€å‘æ¡†æ¶ç”Ÿæˆ  
- **hybrid**: ç»“åˆè®°å¿†å’Œæ¡†æ¶çš„æ··åˆæ¨¡å¼(æ¨è)

**é˜¶æ®µ3: å†…å®¹åŠ è½½**
- æ ¹æ®å›¢é˜Ÿå’Œé¡¹ç›®é…ç½®åŠ è½½ç›¸å…³è®°å¿†
- æ”¯æŒå£°æ˜æ€§ã€ç¨‹åºæ€§ã€æƒ…æ™¯æ€§ä¸‰ç§è®°å¿†ç±»å‹
- åŠ è½½å¯¹åº”çš„æ¡†æ¶æ¨¡æ¿å†…å®¹

**é˜¶æ®µ4: æ™ºèƒ½åŒ¹é…**
- ä½¿ç”¨å¤šç»´åº¦è¯„åˆ†ç®—æ³•åŒ¹é…ç›¸å…³è®°å¿†
- è®¡ç®—è¯­ä¹‰ç›¸å…³æ€§å’Œé‡è¦æ€§æƒé‡
- æ”¯æŒæ‰¹é‡å¹¶è¡Œå¤„ç†ä¼˜åŒ–æ€§èƒ½

**é˜¶æ®µ5: å†…å®¹ç”Ÿæˆ**
- å°†åŒ¹é…çš„è®°å¿†ä¸æ¡†æ¶æ¨¡æ¿æ•´åˆ
- ç”Ÿæˆç»“æ„åŒ–çš„System Prompt
- è‡ªåŠ¨ä¿å­˜åˆ°æŒ‡å®šè¾“å‡ºç›®å½•

**é˜¶æ®µ6: å­¦ä¹ åé¦ˆ**
- è®°å½•ç”Ÿæˆä¼šè¯ä¿¡æ¯
- è§¦å‘è‡ªå­¦ä¹ æœºåˆ¶æ›´æ–°å…³é”®è¯çŸ©é˜µ
- æ”¯æŒç”¨æˆ·åé¦ˆä¼˜åŒ–

### 2. æ™ºèƒ½è®°å¿†åŒ¹é…ç®—æ³•æµç¨‹

```mermaid
flowchart TD
    UserMsg[ç”¨æˆ·æ¶ˆæ¯è¾“å…¥] --> KeywordExtract[å…³é”®è¯æå–]
    
    KeywordExtract --> TechFilter[æŠ€æœ¯è¯æ±‡è¿‡æ»¤]
    TechFilter --> StopWords[åœç”¨è¯å»é™¤]
    StopWords --> Keywords[å…³é”®è¯åˆ—è¡¨]
    
    Keywords --> MemoryLoop[éå†æ‰€æœ‰è®°å¿†]
    MemoryLoop --> MemoryItem[å•ä¸ªè®°å¿†é¡¹]
    
    MemoryItem --> TagMatch[æ ‡ç­¾åŒ¹é…è¯„åˆ†]
    MemoryItem --> ContentMatch[å†…å®¹åŒ¹é…è¯„åˆ†]
    MemoryItem --> ProjectMatch[é¡¹ç›®åŒ¹é…è¯„åˆ†]
    MemoryItem --> PhraseMatch[çŸ­è¯­åŒ¹é…è¯„åˆ†]
    MemoryItem --> SemanticMatch[è¯­ä¹‰åŒ¹é…è¯„åˆ†]
    
    TagMatch --> WeightCalc[æƒé‡è®¡ç®—]
    ContentMatch --> WeightCalc
    ProjectMatch --> WeightCalc
    PhraseMatch --> WeightCalc
    SemanticMatch --> WeightCalc
    
    WeightCalc --> ImportanceWeight[é‡è¦æ€§åŠ æƒ]
    ImportanceWeight --> FinalScore[æœ€ç»ˆåˆ†æ•°]
    
    FinalScore --> Threshold{åˆ†æ•°â‰¥é˜ˆå€¼?}
    Threshold -->|æ˜¯| AddToResults[åŠ å…¥ç»“æœé›†]
    Threshold -->|å¦| NextMemory[ä¸‹ä¸€ä¸ªè®°å¿†]
    
    AddToResults --> NextMemory
    NextMemory --> MoreMemories{è¿˜æœ‰è®°å¿†?}
    MoreMemories -->|æ˜¯| MemoryItem
    MoreMemories -->|å¦| SortResults[æŒ‰åˆ†æ•°æ’åº]
    
    SortResults --> OptimizedEngine{å¯ç”¨ä¼˜åŒ–å¼•æ“?}
    OptimizedEngine -->|æ˜¯| BatchScoring[æ‰¹é‡è¯„åˆ†ä¼˜åŒ–]
    OptimizedEngine -->|å¦| StandardScoring[æ ‡å‡†è¯„åˆ†]
    
    BatchScoring --> CacheCheck[ç¼“å­˜æ£€æŸ¥]
    CacheCheck --> ParallelCalc[å¹¶è¡Œè®¡ç®—]
    ParallelCalc --> CacheUpdate[æ›´æ–°ç¼“å­˜]
    CacheUpdate --> TopResults[è¿”å›topç»“æœ]
    
    StandardScoring --> TopResults
    TopResults --> LearningTrigger[è§¦å‘å­¦ä¹ æœºåˆ¶]
    LearningTrigger --> End[è¿”å›åŒ¹é…è®°å¿†]
```

#### è¯„åˆ†ç®—æ³•è¯¦è§£

**å¤šç»´åº¦è¯„åˆ†æœºåˆ¶**:
```python
# ç»¼åˆè¯„åˆ†è®¡ç®—
score = (
    tag_matching_score * 3.0 +           # æ ‡ç­¾åŒ¹é… (æƒé‡æœ€é«˜)
    content_matching_score * 2.0 +       # å†…å®¹åŒ¹é…
    project_matching_score * 1.5 +       # é¡¹ç›®åŒ¹é…
    phrase_matching_score * 4.0 +        # çŸ­è¯­åŒ¹é… (ç²¾å‡†åŒ¹é…)
    semantic_relevance_score * 1.5       # è¯­ä¹‰ç›¸å…³æ€§
) * importance_weight                     # é‡è¦æ€§åŠ æƒ (1-5æ˜Ÿ)
```

**è¯­ä¹‰ç›¸å…³æ€§è®¡ç®—**:
1. **é¢†åŸŸæ¦‚å¿µå¯†åº¦**: æŠ€æœ¯å…³é”®è¯çš„åŒ¹é…å¯†åº¦
2. **é—®é¢˜-è§£å†³æ–¹æ¡ˆåŒ¹é…**: è¯†åˆ«é—®é¢˜ç±»å‹ä¸è§£å†³æ–¹æ¡ˆçš„å¯¹åº”å…³ç³»
3. **å¤åˆæ¦‚å¿µåŒ¹é…**: è¯†åˆ«å’ŒåŒ¹é…å¤æ‚çš„æŠ€æœ¯æ¦‚å¿µç»„åˆ
4. **æŠ€æœ¯æ ˆç›¸å…³æ€§**: åŸºäºæŠ€æœ¯æ ˆçš„ç›¸å…³æ€§è¯„åˆ†

### 3. è‡ªå­¦ä¹ è¯„åˆ†å¼•æ“å·¥ä½œæµç¨‹

```mermaid
flowchart TD
    Start[ç³»ç»Ÿå¯åŠ¨] --> LoadMatrix[åŠ è½½å…³é”®è¯çŸ©é˜µ]
    LoadMatrix --> MatrixExists{çŸ©é˜µæ–‡ä»¶å­˜åœ¨?}
    
    MatrixExists -->|æ˜¯| LoadExisting[åŠ è½½å·²æœ‰çŸ©é˜µ]
    MatrixExists -->|å¦| InitMatrix[åˆå§‹åŒ–é»˜è®¤çŸ©é˜µ]
    
    LoadExisting --> Ready[å¼•æ“å°±ç»ª]
    InitMatrix --> Ready
    
    Ready --> UserQuery[æ¥æ”¶ç”¨æˆ·æŸ¥è¯¢]
    UserQuery --> AnalyzeQuery[åˆ†ææŸ¥è¯¢å†…å®¹]
    
    AnalyzeQuery --> KeywordDiscover[å…³é”®è¯å‘ç°]
    KeywordDiscover --> TechPattern[æŠ€æœ¯æ¨¡å¼è¯†åˆ«]
    TechPattern --> ConfidenceCalc[ç½®ä¿¡åº¦è®¡ç®—]
    
    ConfidenceCalc --> HighConfidence{ç½®ä¿¡åº¦â‰¥é˜ˆå€¼?}
    HighConfidence -->|æ˜¯| AddKeyword[è‡ªåŠ¨æ·»åŠ å…³é”®è¯]
    HighConfidence -->|å¦| SkipAdd[è·³è¿‡æ·»åŠ ]
    
    AddKeyword --> UpdateMatrix[æ›´æ–°çŸ©é˜µæƒé‡]
    SkipAdd --> UpdateMatrix
    
    UpdateMatrix --> ScoreMemories[å¯¹è®°å¿†é¡¹è¯„åˆ†]
    ScoreMemories --> UsageStats[è®°å½•ä½¿ç”¨ç»Ÿè®¡]
    
    UsageStats --> LearningCheck[æ£€æŸ¥å­¦ä¹ æ¡ä»¶]
    LearningCheck --> StabilityCheck[ç¨³å®šæ€§æ£€æŸ¥]
    
    StabilityCheck --> Stable{å…³é”®è¯å·²ç¨³å®š?}
    Stable -->|æ˜¯| MinimalAdjust[æœ€å°è°ƒæ•´]
    Stable -->|å¦| ActiveLearning[ç§¯æå­¦ä¹ ]
    
    MinimalAdjust --> WeightUpdate[æƒé‡æ›´æ–°]
    ActiveLearning --> WeightUpdate
    
    WeightUpdate --> UserFeedback{æ”¶åˆ°ç”¨æˆ·åé¦ˆ?}
    UserFeedback -->|æ˜¯| ProcessFeedback[å¤„ç†åé¦ˆ]
    UserFeedback -->|å¦| SaveMatrix[ä¿å­˜çŸ©é˜µ]
    
    ProcessFeedback --> FeedbackScore[åé¦ˆè¯„åˆ†]
    FeedbackScore --> AdjustWeights[è°ƒæ•´æƒé‡]
    AdjustWeights --> SaveMatrix
    
    SaveMatrix --> GenerateReport[ç”Ÿæˆå­¦ä¹ æŠ¥å‘Š]
    GenerateReport --> BackToReady[å›åˆ°å°±ç»ªçŠ¶æ€]
    BackToReady --> UserQuery
```

#### å­¦ä¹ æœºåˆ¶è¯¦è§£

**å…³é”®è¯å‘ç°ç®—æ³•**:
- **æŠ€æœ¯æ¨¡å¼è¯†åˆ«**: CamelCaseã€è¿å­—ç¬¦ã€æŠ€æœ¯åç¼€
- **ç½®ä¿¡åº¦è¯„ä¼°**: åŸºäºå¤šä¸ªå› å­çš„ç»¼åˆè¯„åˆ†
- **è‡ªåŠ¨æ·»åŠ **: é«˜ç½®ä¿¡åº¦å…³é”®è¯è‡ªåŠ¨åŠ å…¥çŸ©é˜µ

**æƒé‡è°ƒæ•´ç­–ç•¥**:
```python
# è‡ªé€‚åº”æƒé‡è®¡ç®—
adjusted_weight = base_weight Ã— stability_factor Ã— performance_factor

# ç¨³å®šæ€§å› å­ (å­¦ä¹ æœŸ vs ç¨³å®šæœŸ)
stability_factor = 1.0 + (learning_rate Ã— usage_ratio)  # å­¦ä¹ æœŸ
stability_factor = 1.0 + (learning_rate Ã— 0.1)         # ç¨³å®šæœŸ

# æ€§èƒ½å› å­ (åŸºäºè´¡çŒ®åº¦)
performance_factor = 1.1   # é«˜æ€§èƒ½ (è´¡çŒ®åº¦ > 0.8)
performance_factor = 0.9   # ä½æ€§èƒ½ (è´¡çŒ®åº¦ < 0.3)
performance_factor = 1.0   # ä¸€èˆ¬æ€§èƒ½
```

### 4. ä¸ƒæ­¥æ¡†æ¶åº”ç”¨æµç¨‹

```mermaid
flowchart TD
    UserRequest[ç”¨æˆ·éœ€æ±‚] --> S1[ğŸ¯ æ­¥éª¤1: éœ€æ±‚é”šå®š]
    S1 --> Extract[æå–æ ¸å¿ƒéœ€æ±‚æœ¬è´¨]
    Extract --> Goals[æ˜ç¡®æ ¹æœ¬ç›®æ ‡]
    
    Goals --> S2[ğŸ—ï¸ æ­¥éª¤2: ä¸šåŠ¡æ¨¡å‹]
    S2 --> Entities[æ„å»ºä¸šåŠ¡å®ä½“]
    Entities --> Relations[å®šä¹‰å®ä½“å…³ç³»]
    Relations --> DataFlow[è®¾è®¡æ•°æ®æµ]
    
    DataFlow --> S3[ğŸ’¡ æ­¥éª¤3: è§£å†³æ–¹æ¡ˆ]
    S3 --> Architecture[é«˜å±‚æ¶æ„è®¾è®¡]
    Architecture --> TechStack[æŠ€æœ¯æ ˆé€‰æ‹©]
    TechStack --> Strategy[å®ç°ç­–ç•¥]
    
    Strategy --> S4[ğŸ”§ æ­¥éª¤4: ç»“æ„å®šä¹‰]
    S4 --> Components[å®šä¹‰ç³»ç»Ÿç»„ä»¶]
    Components --> Dependencies[ç»„ä»¶ä¾èµ–å…³ç³»]
    Dependencies --> Interfaces[æ¥å£è®¾è®¡]
    
    Interfaces --> S5[ğŸ“‹ æ­¥éª¤5: ä»»åŠ¡ç¼–æ’]
    S5 --> Breakdown[ä»»åŠ¡åˆ†è§£]
    Breakdown --> Sequence[æ‰§è¡Œåºåˆ—]
    Sequence --> Resources[èµ„æºåˆ†é…]
    
    Resources --> S6[ğŸ”„ æ­¥éª¤6: é€šç”¨ä»»åŠ¡]
    S6 --> Standards[ç¼–ç æ ‡å‡†]
    Standards --> Patterns[é€šç”¨æ¨¡å¼]
    Patterns --> Templates[æ¨¡æ¿å®šä¹‰]
    
    Templates --> S7[âš–ï¸ æ­¥éª¤7: çº¦æŸæ§åˆ¶]
    S7 --> Boundaries[è¾¹ç•Œæ¡ä»¶]
    Boundaries --> Quality[è´¨é‡æ ‡å‡†]
    Quality --> Validation[éªŒè¯è§„åˆ™]
    
    Validation --> Integration[æ¡†æ¶æ•´åˆ]
    Integration --> Memory[è®°å¿†èåˆ]
    Memory --> Prompt[ç”ŸæˆSystem Prompt]
    
    Prompt --> Review[è´¨é‡æ£€æŸ¥]
    Review --> Valid{ç¬¦åˆæ ‡å‡†?}
    Valid -->|æ˜¯| Output[è¾“å‡ºç»“æœ]
    Valid -->|å¦| Refine[ä¼˜åŒ–è°ƒæ•´]
    
    Refine --> S3
    Output --> End[å®Œæˆ]
```

#### ä¸ƒæ­¥æ¡†æ¶è¯¦è§£

**æ­¥éª¤1: éœ€æ±‚é”šå®š (Requirements)**
- æå–éœ€æ±‚çš„æ ¸å¿ƒæœ¬è´¨å’Œæ ¹æœ¬ç›®æ ‡
- è¿‡æ»¤è¡¨é¢éœ€æ±‚ï¼ŒæŒ–æ˜æ·±å±‚éœ€æ±‚
- ç¡®ä¿éœ€æ±‚çš„æ˜ç¡®æ€§å’Œå®Œæ•´æ€§

**æ­¥éª¤2: ä¸šåŠ¡æ¨¡å‹ (Business Model)**
- æ„å»ºæ¸…æ™°çš„ä¸šåŠ¡å®ä½“å…³ç³»æ¨¡å‹
- å®šä¹‰æ•°æ®æµå’Œä¸šåŠ¡æµç¨‹
- ä¸ºåç»­è®¾è®¡æä¾›æ¦‚å¿µåŸºç¡€

**æ­¥éª¤3: è§£å†³æ–¹æ¡ˆ (Solution)**
- æä¾›é«˜å±‚æ¬¡çš„è§£å†³ç­–ç•¥å’Œæ¶æ„æ–¹æ¡ˆ
- é€‰æ‹©åˆé€‚çš„æŠ€æœ¯æ ˆå’Œå®ç°æ–¹å‘
- æŒ‡å¯¼å…·ä½“å®ç°çš„æŠ€æœ¯å†³ç­–

**æ­¥éª¤4: ç»“æ„å®šä¹‰ (Structure)**
- å®šä¹‰ç³»ç»Ÿçš„æŠ€æœ¯æ¶æ„å’Œç»„ä»¶å…³ç³»
- æ˜ç¡®æ¨¡å—è¾¹ç•Œå’Œæ¥å£è®¾è®¡
- ç¡®ä¿æ¶æ„çš„å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§

**æ­¥éª¤5: ä»»åŠ¡ç¼–æ’ (Tasks)**
- å°†æŠ½è±¡æ–¹æ¡ˆè½¬åŒ–ä¸ºå…·ä½“å¯æ‰§è¡Œçš„å®ç°ä»»åŠ¡
- å®šä¹‰ä»»åŠ¡çš„æ‰§è¡Œé¡ºåºå’Œä¾èµ–å…³ç³»
- åˆ†é…åˆé€‚çš„èµ„æºå’Œæ—¶é—´å®‰æ’

**æ­¥éª¤6: é€šç”¨ä»»åŠ¡ (Common Tasks)**
- å®šä¹‰ç»Ÿä¸€çš„ç¼–ç è§„èŒƒå’Œé€šç”¨å®ç°æ¨¡å¼
- å»ºç«‹å¯å¤ç”¨çš„ç»„ä»¶å’Œæ¨¡æ¿
- ç¡®ä¿ä»£ç è´¨é‡å’Œä¸€è‡´æ€§

**æ­¥éª¤7: çº¦æŸæ§åˆ¶ (Constraints)**
- å®šä¹‰æ˜ç¡®çš„è¾¹ç•Œæ¡ä»¶å’Œè´¨é‡æ ‡å‡†
- å»ºç«‹éªŒè¯è§„åˆ™å’Œæµ‹è¯•ç­–ç•¥
- ç¡®ä¿æœ€ç»ˆäº¤ä»˜çš„è´¨é‡å’Œå¯é æ€§

## ğŸ”§ å…³é”®ç®—æ³•å®ç°

### 1. å…³é”®è¯æå–ç®—æ³•

```python
def _extract_keywords_from_message(self, message: str) -> List[str]:
    """ä»ç”¨æˆ·æ¶ˆæ¯ä¸­æå–å…³é”®è¯"""
    
    # åœç”¨è¯è¿‡æ»¤
    stop_words = {
        'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
        'æˆ‘', 'ä½ ', 'ä»–', 'å¥¹', 'çš„', 'äº†', 'åœ¨', 'æ˜¯', 'æœ‰', 'è¿™', 'é‚£'
    }
    
    keywords = []
    
    # è‹±æ–‡è¯æ±‡å¤„ç†
    english_words = re.findall(r'[a-zA-Z]+', message)
    for word in english_words:
        if len(word) >= 3 and word.lower() not in stop_words:
            keywords.append(word.lower())
    
    # æŠ€æœ¯æœ¯è¯­è¯†åˆ«
    tech_patterns = [
        r'å·¥ä½œæµ', r'workflow', r'API', r'api', r'æ¥å£', r'æ•°æ®åº“', r'database',
        r'è®¤è¯', r'authentication', r'æƒé™', r'authorization', r'ç®¡ç†', r'service'
    ]
    
    for pattern in tech_patterns:
        matches = re.findall(pattern, message, re.IGNORECASE)
        keywords.extend([match.lower() for match in matches])
    
    return list(set(keywords))  # å»é‡
```

### 2. è¯­ä¹‰ç›¸å…³æ€§ç®—æ³•

```python
def _calculate_semantic_relevance(self, memory: MemoryEntry, keywords: List[str], message: str) -> float:
    """è®¡ç®—è¯­ä¹‰ç›¸å…³æ€§å¾—åˆ†"""
    semantic_score = 0.0
    
    # 1. é¢†åŸŸæ¦‚å¿µå¯†åº¦è¯„åˆ† (0-10åˆ†)
    domain_keywords = ['api', 'workflow', 'solution', 'rule', 'validation']
    user_concepts = [kw for kw in keywords if kw in domain_keywords]
    memory_text = memory.content.lower() + ' ' + ' '.join(memory.tags).lower()
    
    if user_concepts:
        matches = sum(1 for concept in user_concepts if concept in memory_text)
        domain_density = (matches / len(user_concepts)) * 10
        semantic_score += domain_density
    
    # 2. é—®é¢˜-è§£å†³æ–¹æ¡ˆåŒ¹é…åº¦ (0-15åˆ†)
    problem_solution_pairs = [
        (['enhance', 'improve', 'add'], ['design', 'architecture', 'implementation']),
        (['validate', 'check', 'ensure'], ['validation', 'verification', 'logic']),
        (['create', 'build', 'generate'], ['creation', 'construction', 'workflow'])
    ]
    
    for problem_words, solution_words in problem_solution_pairs:
        has_problem = any(word in keywords for word in problem_words)
        has_solution = any(word in memory_text for word in solution_words)
        if has_problem and has_solution:
            semantic_score += 3.0
    
    return semantic_score
```

### 3. æ‰¹é‡ä¼˜åŒ–è¯„åˆ†ç®—æ³•

```python
def batch_calculate_scores(self, user_message: str, memories: List[MemoryEntry], max_workers: int = 4) -> List[Tuple]:
    """æ‰¹é‡å¹¶è¡Œè®¡ç®—è¯„åˆ†"""
    import concurrent.futures
    
    def calculate_single_score(memory):
        try:
            # æ£€æŸ¥ç¼“å­˜
            cache_key = f"{hash(user_message)}_{memory.id}"
            if cache_key in self.score_cache:
                return memory.id, self.score_cache[cache_key], {'cached': True}
            
            # è®¡ç®—æ–°è¯„åˆ†
            score, details = self.calculate_memory_score(user_message, memory)
            
            # æ›´æ–°ç¼“å­˜
            self.score_cache[cache_key] = score
            return memory.id, score, details
            
        except Exception as e:
            return memory.id, 0.0, {'error': str(e)}
    
    # å¹¶è¡Œå¤„ç†
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        results = list(executor.map(calculate_single_score, memories))
    
    return results
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. ç¼“å­˜ä¼˜åŒ–
- **è¯„åˆ†ç¼“å­˜**: ç¼“å­˜ç”¨æˆ·æ¶ˆæ¯å’Œè®°å¿†çš„è¯„åˆ†ç»“æœ
- **æ–‡ä»¶ç¼“å­˜**: ç¼“å­˜ç»å¸¸è®¿é—®çš„è®°å¿†æ–‡ä»¶å†…å®¹
- **çŸ©é˜µç¼“å­˜**: ç¼“å­˜å…³é”®è¯çŸ©é˜µä»¥é¿å…é‡å¤åŠ è½½

### 2. å¹¶è¡Œå¤„ç†
- **æ‰¹é‡è¯„åˆ†**: å¹¶è¡Œè®¡ç®—å¤šä¸ªè®°å¿†é¡¹çš„ç›¸å…³æ€§è¯„åˆ†
- **å¤šçº¿ç¨‹å¤„ç†**: åˆ©ç”¨å¤šçº¿ç¨‹å¤„ç†IOå¯†é›†å‹æ“ä½œ
- **å¼‚æ­¥APIè°ƒç”¨**: å¼‚æ­¥å¤„ç†AIæ¨¡å‹APIè°ƒç”¨

### 3. ç®—æ³•ä¼˜åŒ–
- **æ—©æœŸè¿‡æ»¤**: åœ¨è¯¦ç»†è¯„åˆ†å‰è¿›è¡Œåˆæ­¥è¿‡æ»¤
- **å¢é‡å­¦ä¹ **: ä»…æ›´æ–°å˜åŒ–çš„éƒ¨åˆ†è€Œéé‡æ–°è®¡ç®—å…¨éƒ¨
- **å†…å­˜ç®¡ç†**: åŠæ—¶é‡Šæ”¾ä¸å†ä½¿ç”¨çš„å¤§å¯¹è±¡

### 4. æ•°æ®ç»“æ„ä¼˜åŒ–
- **ç´¢å¼•å»ºç«‹**: ä¸ºç»å¸¸æŸ¥è¯¢çš„å­—æ®µå»ºç«‹ç´¢å¼•
- **æ•°æ®å‹ç¼©**: å‹ç¼©å­˜å‚¨å¤§å‹æ•°æ®ç»“æ„
- **æƒ°æ€§åŠ è½½**: æŒ‰éœ€åŠ è½½æ•°æ®è€Œéä¸€æ¬¡æ€§åŠ è½½å…¨éƒ¨

è¿™äº›æ ¸å¿ƒæµç¨‹å’Œç®—æ³•ç¡®ä¿äº†ç³»ç»Ÿçš„é«˜æ•ˆæ€§ã€å‡†ç¡®æ€§å’Œå¯æ‰©å±•æ€§ï¼Œä¸ºç”¨æˆ·æä¾›ä¼˜è´¨çš„æ™ºèƒ½ä¸Šä¸‹æ–‡ç”ŸæˆæœåŠ¡ã€‚