{
  "team_name": "engineering_team",
  "mode": "hybrid",
  "content": "先理解记忆的内容，再基于七步框架结合user_message生成具体的结构化提示词\n\n---\n\n# 七步框架模板内容\n\n\n# 需求锚定（Requirements）\n\n## 目标\n从需求描述中提取核心问题本质和根本目标\n\n## 输出格式\n```\n## Requirements\n[使用简洁的动词短语描述需求的本质，避免功能特性列举]\n```\n\n## 构建要点\n- **本质提炼**：抽象出解决什么根本问题、为谁创造什么价值\n- **边界定义**：明确解决方案的适用范围和限制条件\n- **价值聚焦**：突出业务价值和用户获益\n- **使用动词短语**：如\"Implement...\"、\"Create...\"、\"Design...\"\n- **避免特征堆砌**：不要列举具体功能，要抽象出需要解决的本质问题\n\n## 质量标准\n- 一句话能概括核心需求\n- 体现业务价值而非技术实现\n- 明确问题边界和约束 \n\n---\n\n# 业务模型（Business Model）\n\n## 目标\n构建清晰的业务实体关系模型，为后续设计提供概念基础\n\n## 输出格式\n```\n## Business Model\n```mermaid\nclassDiagram\ndirection TB\n\nclass [CoreEntity] {\n    +[AttributeType] [attributeName]\n    +[AttributeType] [attributeName]\n    +[Method]()\n}\n\nclass [RelatedEntity] {\n    +[AttributeType] [attributeName]\n    +[Method]()\n}\n\nclass [RequestDTO] {\n    +[AttributeType] [attributeName]\n    +[ValidationRule]\n}\n\nclass [ResponseDTO] {\n    +[AttributeType] [attributeName]\n    +[StaticMethod]()\n}\n\n[CoreEntity] \"[cardinality]\" -- \"[cardinality]\" [RelatedEntity] : [relationshipDesc]\n[RequestDTO] --> [CoreEntity] : creates\n[CoreEntity] --> [ResponseDTO] : maps to\n```\n\n## 构建要点\n- **实体识别**：识别核心业务实体、支撑实体、DTO对象\n- **属性建模**：为每个实体定义关键属性，使用\"类型+名称\"格式\n- **关系建模**：明确实体间的关系类型（1:1, 1:N, N:M）和业务语义\n- **现有实现优先**：如果当前数据结构能够满足需求，必须保持现有实现不变\n- **最小变更原则**：仅在现有结构确实无法支持新需求时才进行重构\n- **接口设计**：包含关键的方法和静态工厂方法\n- **数据流向**：体现请求->处理->响应的完整数据流\n- **一致性保障**：确保模型能被AI准确理解和实现\n- **简洁 > 功能丰富**：避免过度工程化，保持系统可理解性\n\n## 保守性约束\n- **禁止不必要重构**：如果现有简单数据类型（如List<String>）能满足需求，严禁创建复杂实体包装\n- **功能驱动变更**：只有在明确的功能需求无法通过现有结构实现时，才考虑结构调整\n- **渐进式改进**：优先考虑在现有结构基础上扩展，而非推倒重建\n- **向后兼容**：任何结构变更必须保证向后兼容，避免破坏性变更\n\n## 质量标准\n- 关注当前任务流程\n- 实体关系清晰准确\n- 支持后续技术实现\n- 保持现有实现的简洁性\n- 避免过度抽象和不必要的复杂性 \n\n---\n\n# 解决方案（Solution）\n\n## 目标\n提供高层次的解决策略和架构方案，指导具体实现\n\n## 输出格式\n```\n## Solution\n1. [Solution Category]:\n   - [High-level strategy description]\n   - [Architecture pattern or approach]\n   - [Key design decisions and rationale]\n   - [Alternative approaches consideration]\n\n2. [Technical Implementation]:\n   - [Framework or technology choice]\n   - [Integration pattern]\n   - [Performance and security considerations]\n   - [Global exception handling strategy with GlobalExceptionHandler]\n\n3. [Business Logic]:\n   - [Core business rules]\n   - [Validation and error handling strategy]\n   - [Workflow and process design]\n```\n\n## 构建要点\n- **分类组织**：按解决方案类别组织（如API设计、数据处理、异常处理等）\n- **架构决策**：提供关键的技术架构选择和设计模式\n- **最佳实践**：结合行业标准和经验总结\n- **决策依据**：说明为什么选择特定方案的原因\n- **风险评估**：识别潜在风险和应对策略\n\n## 质量标准\n- 方案具有可操作性\n- 涵盖关键技术决策\n- 体现架构思维 \n\n---\n\n# 结构定义（Structure）\n\n## 目标\n定义系统的技术架构和组件依赖关系\n\n## 输出格式\n```\n## Structure\n\n### 继承关系（Inheritance Relationships）\n1. [Interface] interface定义[functionality description]\n2. [Implementation] implements [Interface] interface\n3. [DomainModel] extends [BaseModel] class\n4. [Controller] extends [BaseController] class\n5. [BusinessException] extends RuntimeException class（业务异常基类）\n6. [SpecificBusinessException] extends [BusinessException] class（具体业务异常类）\n\n### 依赖关系（Dependencies）\n1. [ComponentA] 调用 [ComponentB]\n2. [Service] 依赖 [Repository] 和 [ExternalService]\n3. [Controller] 注入 [Service] 和 [ValidationService]\n\n### 分层架构（Layered Architecture）\n1. Controller Layer: [ResponsibilityDescription]\n2. Service Layer: [ResponsibilityDescription]\n3. Repository Layer: [ResponsibilityDescription]\n4. Data Access Layer: [ResponsibilityDescription]\n5. Exception Handling Layer: [GlobalExceptionHandler for unified error handling]\n```\n\n## 构建要点\n- **继承体系**：明确接口、抽象类、实现类的继承关系\n- **依赖链路**：定义组件间的调用和依赖关系\n- **分层设计**：体现清晰的分层架构（Controller -> Service -> Repository -> DAO）\n- **职责分离**：每层的职责边界和交互接口\n- **扩展接口**：为未来功能扩展预留的接口和扩展点\n\n## 质量标准\n- 架构层次清晰\n- 依赖关系合理\n- 支持系统扩展 \n\n---\n\n# 任务编排（Tasks）\n\n## 目标\n将抽象方案转化为具体可执行的实现任务\n\n## 输出格式\n```\n## Tasks\n\n### 创建/更新/删除[ComponentType] - [ComponentName]类\n1. 职责：[Clear responsibility description]\n2. 属性：\n   - [attributeName]: [Type] - [Description]\n   - [attributeName]: [Type] - [Description with validation rules]\n3. 方法：\n   - [methodName]([parameters]): [ReturnType]\n     - 逻辑：\n       - [Step-by-step implementation logic]\n       - [Conditional logic and edge cases]\n       - [Error handling approach]\n4. 注解：\n   - [RequiredAnnotations for framework integration]\n5. 约束：\n   - [Validation rules and business constraints]\n\n### 实现[ServiceType] - [ServiceName]服务\n1. 接口定义：[Interface methods and contracts]\n2. 核心方法：[methodName]([parameters]): [ReturnType]\n   - 输入验证：[Input validation rules]\n   - 业务逻辑：[Core business logic steps]\n   - 异常处理：[Exception handling strategy]\n   - 返回值：[Return value construction]\n3. 依赖注入：[Required dependencies]\n4. 事务管理：[Transaction boundary definition]\n\n### 配置[ConfigurationType] - [ConfigurationName]\n1. 配置项：[Configuration parameters]\n2. 默认值：[Default value settings]\n3. 环境变量：[Environment-specific settings]\n4. 验证规则：[Configuration validation]\n\n### 创建异常处理器 - GlobalExceptionHandler\n1. 职责：统一处理全局异常，提供标准化错误响应\n2. 异常类型：\n   - BusinessException: [Business logic exceptions]\n   - ValidationException: [Input validation exceptions]\n   - SystemException: [System-level exceptions]\n   - RuntimeException: [Unexpected runtime exceptions]\n3. 方法：\n   - handleBusinessException(BusinessException): ResponseEntity<ErrorResponse>\n   - handleValidationException(ValidationException): ResponseEntity<ErrorResponse>\n   - handleSystemException(SystemException): ResponseEntity<ErrorResponse>\n   - handleGenericException(Exception): ResponseEntity<ErrorResponse>\n4. 注解：\n   - @RestControllerAdvice\n   - @ExceptionHandler for each exception type\n5. 响应格式：\n   - 统一的错误响应结构（错误码、错误消息、时间戳等）\n\n### 创建业务异常类 - [BusinessExceptionName]\n1. 职责：定义特定业务场景的异常类型，提供清晰的错误信息和错误码\n2. 继承关系：\n   - extends RuntimeException 或 extends BusinessException（如果有基础业务异常类）\n3. 属性：\n   - errorCode: String - 业务错误码（如：USER_NOT_FOUND, INVALID_OPERATION等）\n   - errorMessage: String - 详细错误描述\n   - timestamp: LocalDateTime - 异常发生时间\n   - context: Map<String, Object> - 异常上下文信息（可选）\n4. 构造方法：\n   - [ExceptionName](String errorCode, String errorMessage)\n   - [ExceptionName](String errorCode, String errorMessage, Throwable cause)\n   - [ExceptionName](String errorCode, String errorMessage, Map<String, Object> context)\n5. 方法：\n   - getErrorCode(): String - 获取错误码\n   - getErrorMessage(): String - 获取错误消息\n   - getContext(): Map<String, Object> - 获取上下文信息\n   - toString(): String - 格式化异常信息\n6. 使用场景：\n   - [Specific business scenarios where this exception should be thrown]\n   - [Validation rules that trigger this exception]\n   - [Business logic conditions that warrant this exception]\n7. 异常分类：\n   - 数据异常：如 DataNotFoundException, DataConflictException\n   - 权限异常：如 UnauthorizedException, ForbiddenException\n   - 业务规则异常：如 BusinessRuleViolationException, InvalidStateException\n   - 外部依赖异常：如 ExternalServiceException, IntegrationException\n```\n\n## 构建要点\n- **基于前四阶段**：严格基于需求、模型、方案、结构的完整上下文\n- **任务分类**：按功能模块或组件类型分组（实体类、服务类、控制器等）\n- **实现细节**：包含具体的代码规范、配置要求、业务逻辑\n- **执行顺序**：按依赖关系组织任务执行顺序\n- **职责单一**：每个任务职责明确且边界清晰\n- **可验证性**：每个任务都有明确的完成标准\n- **逻辑严谨性**：确保任务编排基于业务模型、解决方案、结构化设计，避免出现逻辑漏洞，保证上下文数据流的连贯性\n\n## 质量标准\n- 任务可直接执行\n- 覆盖完整实现\n- 细节准确具体 \n\n---\n\n# 通用任务（Common Tasks）\n\n## 目标\n定义统一的编码规范和通用实现模式\n\n## 输出格式\n```\n## Common Tasks\n1. 注解规范：[Specific annotation requirements for different component types]\n2. 依赖注入：[Dependency injection patterns and best practices]  \n3. 异常处理：[Unified exception handling approach via GlobalExceptionHandler]\n   - 自定义异常类型定义和继承关系\n   - 业务异常类创建标准：\n     * 继承RuntimeException或自定义BusinessException基类\n     * 必须包含errorCode（业务错误码）和errorMessage（错误描述）\n     * 提供多种构造方法支持不同场景\n     * 按业务领域分类（数据异常、权限异常、业务规则异常、外部依赖异常）\n   - 统一错误响应格式（ErrorResponse DTO）\n   - 异常处理器方法的标准实现模式\n   - 日志记录和异常跟踪机制\n4. 数据验证：[Common validation patterns and rules]\n5. 日志记录：[Logging standards and patterns]\n6. 文档规范：[Documentation and comment standards]\n```\n\n## 构建要点\n- **标准化**：定义统一的编码规范和配置模式\n- **复用性**：提取可复用的通用实现模式\n- **一致性**：确保所有组件遵循相同的标准\n- **质量保障**：内置验证和校验机制\n- **最佳实践**：体现行业最佳实践和经验总结\n\n## 质量标准\n- 规范明确具体\n- 易于执行检查\n- 体现最佳实践 \n\n---\n\n# 约束控制（Constraints）\n\n## 目标\n定义明确的边界条件和质量标准\n\n## 输出格式\n```\n## Constraints\n1. 功能约束：[Functional requirements and limitations with specific criteria]\n2. 性能约束：[Performance requirements with measurable metrics]\n3. 安全约束：[Security requirements and compliance standards]\n4. 集成约束：[Integration limitations and compatibility requirements]\n5. 业务规则约束：[Business rule validation with specific conditions]\n6. 异常处理约束：[Exception handling standards and requirements]\n   - 业务异常必须包含明确的错误码和错误消息\n   - 异常类型必须按业务领域分类和命名\n   - 异常信息不得暴露敏感的系统内部信息\n   - 所有业务异常必须被GlobalExceptionHandler统一处理\n7. 技术约束：[Technical implementation restrictions and standards]\n8. 数据约束：[Data validation rules and format requirements]\n9. API约束：[API design standards and interface contracts]\n```\n\n## 构建要点\n- **边界明确**：清晰定义可以做什么和不能做什么\n- **可验证性**：约束条件应该可以验证\n- **完整性**：覆盖功能、性能、安全、集成等各个方面\n- **实用性**：约束应该有助于提高代码质量和系统稳定性\n- **量化标准**：尽可能提供可量化的标准和指标\n\n## 质量标准\n- 约束条件明确\n- 可验证\n- 覆盖面完整 \n\n---\n",
  "source_memories": [],
  "framework_stages": [
    "requirements",
    "business-model",
    "solution",
    "structure",
    "tasks",
    "common-tasks",
    "constraints"
  ],
  "metadata": {
    "memory_count": 0,
    "total_memories_available": 0,
    "framework_stages_count": 7,
    "hybrid_mode": true
  },
  "generation_time": "2025-07-23T12:55:05.113146"
}